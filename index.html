<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=no">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300" rel="stylesheet" async>
    <link rel="manifest" href="/manifest.json">
    <link rel="import" href="./bower_components/paper-slider/paper-slider.html">
    <title>sfz convert</title>
    <style>
        [wrapper-main]{
            margin:50px ; 
        }
        body {
            padding: 0;
            margin: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            background-color: #E5E1DF;
        }
        [wrapper] {
            margin: 150px;
            margin-top: 100px ;
        }
        .thumb {
            height: 75px;
            border: 1px solid #000;
            margin: 10px 5px 0 0;
        }
    </style>
    <style fileChooser>
        [wrapper], [fileChooser], [progress] {
            padding: 5px 10px;
            background: #4775D1;
            border: 1px solid #4775D1;
            position: relative;
            color: #fff;
            border-radius: 2px;
            text-align: center;
            float: left;
        }
        .hide_file {
            position: absolute;
            z-index: 1000;
            opacity: 0;
            right: 0;
            top: 0;
            height: 100%;
            font-size: 24px;
            width: 100%;
        }
        [instructions]{
            font-size: 18px ; 
            margin:100px ; 
        }
    </style>
</head>
<body>
    <div wrapper-main>
        <div wrapper>
            <div fileChooser>
                <span fileChooserText> Seleccionar sfz </span>
                <input type="file" class="hide_file" id="files" name="files[]"/>
            </div>
            <div progress>
            </div>
        </div>
        <div > Calidad de audio </div>
        <paper-slider id='slider' min ='-0.1' max ='1' step='0.1' on-value-change='test()' value='0.7'></paper-slider>
    </div>

    <script src="./javascripts/OggVorbisEncoder.js"></script>
    <script src='./codecs/aurora.js'></script>
    <script src='./codecs/ogg.js'></script>
    <script src='./codecs/vorbis.js'></script>
    <script src="/zipjs/zip.js"></script>
    <script >
        var oggQuality = 0.7 ; 
        var context = new AudioContext() ; 
        
        OggVorbisEncoderConfig = {
            memoryInitializerPrefixURL: "javascripts/" 
        };
        zip.workerScriptsPath = '/zipjs/';
        document.getElementById('slider').addEventListener('change', e => {
            oggQuality = e.target.value ; 
        });
        document.querySelector('input').onclick = function () {
            this.value = null;
        };

        document.querySelector('input').addEventListener('change', async function () {
            document.getElementById('slider').disabled = true ; 
            let zipFileName = this.files[0].name ; 
            let zippedBlob = new Blob([this.files[0]], {type:this.files[0].type}) ; 
            zip.createReader(new zip.BlobReader(zippedBlob), zipReader => {
                zipReader.getEntries(async entries => {
                    let zipWriter , zipWriterPromise = new Promise(resolve => zipWriterPromiseR = resolve);
                    zip.createWriter(new zip.BlobWriter("application/zip"), async res => {
                        zipWriter = res ; 
                        zipWriterPromiseR() ; 
                    }) ; 
                    await zipWriterPromise  ; 
                    let processedFiles = 0 ; 
                    let totalFiles = 0 ; 
                    for(let i = 0 ; i < entries.length ; i ++ ){
                        if(entries[i].filename.endsWith('/'))
                            continue ; 
                        totalFiles ++ ; 
                    }
                    document.querySelector('[fileChooserText]').innerHTML = 'comprimiendo ... ' ; 
                    for(let i = 0 ; i <  entries.length ; i ++ ){
                        if(entries[i].filename.endsWith('/'))
                            continue ; 
                        let entryProcessed = new Promise(resolve => entryProcessedR = resolve);
                        entries[i].getData(new zip.BlobWriter('audio/wav'), blob => {
                            if(!entries[i].filename.endsWith('.wav')) {
                                zipWriter.add(entries[i].filename , new zip.BlobReader(blob), () => {
                                    processedFiles ++ ; 
                                    document.querySelector('[progress]').innerHTML = Math.ceil(processedFiles/totalFiles*100)+'%' ; 
                                    entryProcessedR() ;
                                });
                            }
                            else {
                                let fR = new FileReader();
                                fR.readAsArrayBuffer(blob);
                                fR.onload = async() => {
                                    let bufferView = new Uint32Array(fR.result.slice(24, 28));
                                    let sampleRate = bufferView[0] ; 
                                    let audioBuffer = await context.decodeAudioData(fR.result);
                                    let offlineContext_num_samples = Math.ceil(audioBuffer.duration*sampleRate) ; 
                                    let buffer_online = audioBuffer.getChannelData(0) ; 
                                    let num_samples = buffer_online.length ; 
                                    let offlContext = new OfflineAudioContext(1,offlineContext_num_samples,sampleRate) ; 
                                    let buffer_offline = offlContext.createBuffer(1,num_samples,context.sampleRate) ; 
                                    let buff = buffer_offline.getChannelData(0) ; 
                                    for(let i = 0 ; i < num_samples ; i ++ )
                                        buff[i] = buffer_online[i] ; 
                                    let source = offlContext.createBufferSource() ; 
                                    source.buffer = buffer_offline ; 
                                    source.connect(offlContext.destination) ; 
                                    source.start(0) ; 
                                    offlContext.startRendering().then( renderedBuffer => {
                                        let encoder = new OggVorbisEncoder(sampleRate, 1, oggQuality);
                                        encoder.encode([renderedBuffer.getChannelData(0)]);
                                        let oggBlob = encoder.finish(["application/ogg"]);
                                        zipWriter.add(entries[i].filename.slice(0,-3)+'ogg' , new zip.BlobReader(oggBlob), () => { 
                                            processedFiles ++ ; 
                                            document.querySelector('[progress]').innerHTML = Math.ceil(processedFiles/totalFiles*100)+'%' ; 
                                            entryProcessedR();
                                        }) ; 

                                    }) ; 
                                }
                            }
                        });
                        await entryProcessed ;  
                    }
                    document.querySelector('[fileChooserText]').innerHTML = ' Seleccionar sfz ' ; 
                    document.querySelector('[progress]').innerHTML = '' ; 
                    zipWriter.close( zippedBlob => {
                        let a = document.createElement('a');
                        a.download = zipFileName.slice(0,-4)+'-ogg.zip';
                        let url = window.URL.createObjectURL(zippedBlob);
                        a.href = url;
                        a.click();
                        window.URL.revokeObjectURL(url);
                        zipReader.close();
                        document.getElementById('slider').disabled = false ; 
                    }) ; 
                }, onerror);
            });
        }, false);
    </script>
</body>
</html>